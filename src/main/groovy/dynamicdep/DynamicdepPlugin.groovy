/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package dynamicdep

import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.internal.artifacts.configurations.DefaultConfiguration
import org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin

/**
 * A simple 'hello world' plugin.
 */
public class DynamicdepPlugin implements Plugin<Project> {

    @Override
    public void apply(Project targetProject) {
        // 创建extenstion不能放在afterEvaluate里面，否则找不到 dynamicDependency 方法。
        def rootProject = targetProject.rootProject
        NamedDomainObjectContainer<DependencyResolveExt> dependencyResolveContainer = rootProject.container(DependencyResolveExt.class)
        rootProject.extensions.add("dynamicDependency", dependencyResolveContainer)

        // afterEvalute 发生在 configure 阶段之后。
        targetProject.afterEvaluate {

            def noProjDep = []
            targetProject.parent.getSubprojects().forEach({
                // 加入判断，不然每个项目都要执行一遍 currentProject == it.name

                println(it.name + "的依赖项如下：")
                it.configurations.all({ DefaultConfiguration configuration ->

                    def conName = configuration.name.toLowerCase()
                    // println(configuration.name) 打印看一下就知道这个configuration是什么。
                    if (configuration.dependencies.size() == 0 || conName.contains("oversea") || conName.contains("ent") || conName.contains("testcompile") || conName.contains("annotationprocessor")) {
                        return
                    }

                    configuration.dependencies.all({ dependency ->
                        if (dependency instanceof DefaultProjectDependency) {
                            def depProjectName = dependency.dependencyProject.name
                            // 这里不知道为啥打印自身，还不止一次。 先过滤掉。
                            if (depProjectName != it.name) {
                                println(dependency.dependencyProject.path)
//                                println("依赖方法 " + conName)
                            }
                        }
                    })
                })
            })

//            targetProject.getBuildFile() 返回的是build.gradle的路径
            targetProject.rootProject.getSubprojects().forEach({
                // 加入com.android.library判断，过滤掉不能生成aar的module
//                if (!it.plugins.hasPlugin("com.android.library")) {
//                    return
//                }

                def flavor = ""
                // 这里要修改，com.android.application的类型才有android配置项
                if (it.plugins.hasPlugin("com.android.application") && it.android.productFlavors.size() != 0) {
                    flavor = it.android.productFlavors[0].name + "-"
                    // 取第一个是 cn 类型的。 这个好像和定义的顺序有关。
                    println("flavor: " + flavor)
                    assert flavor == "cn-"
                }
                println("当前flavor: " + flavor)

                it.plugins.apply(MavenPublishPlugin)
                // 这一步相当于给每个module添加了一个上传的task，但是该task还没有调用。 需要主动调用一次才可以。
                def proj = it
                it.publishing {
                    publications {
                        // 这个maven是自定义的字符串
                        wps(MavenPublication) {
                            groupId 'cn.wps'
                            artifactId proj.name
                            version '1.1-SNAPSHOT'

                            // 如何加入判断，是否存在这个aar文件呢. 2、如何读取flavor，直接替换cn
                            def file = new File("${proj.buildDir}/outputs/aar/${proj.name}-cn-debug.aar")   // 字符串中有变量引用的时候不能用单引号
                            def file_2 = new File("${proj.buildDir}/outputs/aar/${proj.name}-debug.aar")   // 字符串中有变量引用的时候不能用单引号
                            def file_3 = new File("${proj.buildDir}/libs/${proj.name}.jar")   // 字符串中有变量引用的时候不能用单引号
                            def final_artifact
                            if (file.exists()) {
                                final_artifact = "${proj.buildDir}/outputs/aar/${proj.name}-cn-debug.aar"
                            } else if (file_2.exists()) {
                                final_artifact = "${proj.buildDir}/outputs/aar/${proj.name}-debug.aar"
                            } else {
                                final_artifact = "${proj.buildDir}/libs/${proj.name}.jar"
                            }

//                            def file_2 = new File('${proj.buildDir}/outputs/aar/${proj.name}-debug.aar')
//                            if (file.exists()) {
//                                println("这里")
//                                artifact "${proj.buildDir}/outputs/aar/${proj.name}-cn-debug.aar"
//                            } else if (file_2.exists()) {
//                                println("这里2")
//                                artifact "${proj.buildDir}/outputs/aar/${proj.name}-debug.aar"
//                            } else {
//                                println("不存在相应的产物!!!")
//                            }
                            artifact final_artifact
                        }
                    }

                    repositories {
                        mavenLocal()
                    }
                }
            })

            // 替换逻辑
            targetProject.rootProject.getSubprojects().forEach({
                def childProject = it
                Map<Project, DependencyResolveExt> resolveExtMap = new HashMap<>()

                childProject.configurations.all { DefaultConfiguration configuration ->
                    if (configuration.dependencies.size() == 0) {
                        return
                    }

                    configuration.dependencies.all { dependency ->
                        if (dependency instanceof DefaultProjectDependency) {
                            def depProjectName = dependency.dependencyProject.name
                            def dependencyResolveExt = dependencyResolveContainer.find {
                                it.name == depProjectName
                            }

                            if (dependencyResolveExt != null) {
                                resolveExtMap.put(dependency.dependencyProject, dependencyResolveExt)
                            }
                        }
                    }
                }

                println("map : " + resolveExtMap)
                childProject.configurations.all { DefaultConfiguration configuration ->
                    if (configuration.dependencies.size() == 0) {
                        return
                    }

                    resolutionStrategy {
                        dependencySubstitution {
                            resolveExtMap.each { key, value ->
                                println("正在替换 implement的路径， 当前工程：" + childProject.name)
                                println("${key.path}")
                                println("${value.groupId}:${getArtifactName(key, value.artifactId)}:${value.version}")
                                // apply方法的参数与这里的project同名了，导致编译错误。 故将apply方法的project参数名改为targetProject
                                // Could not find method call() for arguments [:apt-library] on project ':app' of type org.gradle.api.Project.
//                                substitute project(":apt-library") with module("${value.groupId}:${getArtifactName(key, value.artifactId)}:${value.version}")
                                substitute project("${key.path}") with module("${value.groupId}:${getArtifactName(key, value.artifactId)}:${value.version}")
                                println("替换完毕")
                            }
                        }
                    }
                }
            })

        }

    }

    static def getArtifactName(Project project, String name) {
        if (name == null || name == "") {
            return project.name
        }
        return name
    }
}
